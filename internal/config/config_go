package config

import (
	"fmt"
	"os"
)

package config

import (
	"fmt"
	"os"

	"gopkg.in/yaml.v3"
)

// Config represents the main application configuration
type Config struct {
	Source   SourceConfig   `yaml:"source"`
	Embedder EmbedderConfig `yaml:"embedder"`
	Storage  StorageConfig  `yaml:"storage"`
}

// SourceConfig represents configuration for data sources
type SourceConfig struct {
	Type   string      `yaml:"type"`
	Config interface{} `yaml:"config"`
}

// KafkaConfig represents Kafka specific configuration
type KafkaConfig struct {
	Brokers []string `yaml:"brokers"`
	Topic   string   `yaml:"topic"`
	GroupID string   `yaml:"group_id"`
}

// EmbedderConfig represents configuration for embedding services
type EmbedderConfig struct {
	Type   string      `yaml:"type"`
	Config interface{} `yaml:"config"`
}

// OpenAIConfig represents OpenAI specific configuration
type OpenAIConfig struct {
	Model  string `yaml:"model"`
	APIKey string `yaml:"api_key"`
}

// StorageConfig represents configuration for storage backends
type StorageConfig struct {
	Type   string      `yaml:"type"`
	Config interface{} `yaml:"config"`
}

// QdrantConfig represents Qdrant specific configuration
type QdrantConfig struct {
	URL        string  `yaml:"url"`
	Collection string  `yaml:"collection"`
	VectorSize int     `yaml:"vector_size"`
	Distance   string  `yaml:"distance"`
}

// LoadConfig loads configuration from the specified path
func LoadConfig(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file: %w", err)
	}

	// First, decode the basic structure
	var rawConfig struct {
		Source struct {
			Type   string         `yaml:"type"`
			Config map[string]any `yaml:"config"`
		} `yaml:"source"`
		Embedder struct {
			Type   string         `yaml:"type"`
			Config map[string]any `yaml:"config"`
		} `yaml:"embedder"`
		Storage struct {
			Type   string         `yaml:"type"`
			Config map[string]any `yaml:"config"`
		} `yaml:"storage"`
	}

	err = yaml.Unmarshal(data, &rawConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to parse config: %w", err)
	}

	// Prepare the final config
	config := &Config{
		Source: SourceConfig{
			Type: rawConfig.Source.Type,
		},
		Embedder: EmbedderConfig{
			Type: rawConfig.Embedder.Type,
		},
		Storage: StorageConfig{
			Type: rawConfig.Storage.Type,
		},
	}

	// Parse specific configs based on type
	switch rawConfig.Source.Type {
	case "kafka":
		var kafkaConfig KafkaConfig
		configBytes, err := yaml.Marshal(rawConfig.Source.Config)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal kafka config: %w", err)
		}
		if err := yaml.Unmarshal(configBytes, &kafkaConfig); err != nil {
			return nil, fmt.Errorf("failed to parse kafka config: %w", err)
		}
		config.Source.Config = kafkaConfig
	default:
		return nil, fmt.Errorf("unsupported source type: %s", rawConfig.Source.Type)
	}

	switch rawConfig.Embedder.Type {
	case "openai":
		var openaiConfig OpenAIConfig
		configBytes, err := yaml.Marshal(rawConfig.Embedder.Config)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal openai config: %w", err)
		}
		if err := yaml.Unmarshal(configBytes, &openaiConfig); err != nil {
			return nil, fmt.Errorf("failed to parse openai config: %w", err)
		}
		config.Embedder.Config = openaiConfig
	default:
		return nil, fmt.Errorf("unsupported embedder type: %s", rawConfig.Embedder.Type)
	}

	switch rawConfig.Storage.Type {
	case "qdrant":
		var qdrantConfig QdrantConfig
		configBytes, err := yaml.Marshal(rawConfig.Storage.Config)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal qdrant config: %w", err)
		}
		if err := yaml.Unmarshal(configBytes, &qdrantConfig); err != nil {
			return nil, fmt.Errorf("failed to parse qdrant config: %w", err)
		}
		config.Storage.Config = qdrantConfig
	default:
		return nil, fmt.Errorf("unsupported storage type: %s", rawConfig.Storage.Type)
	}

	return config, nil
}

// GetKafkaConfig returns the Kafka configuration
func (c *Config) GetKafkaConfig() (KafkaConfig, error) {
	if c.Source.Type != "kafka" {
		return KafkaConfig{}, fmt.Errorf("source type is not kafka")
	}

	config, ok := c.Source.Config.(KafkaConfig)
	if !ok {
		return KafkaConfig{}, fmt.Errorf("invalid kafka config type")
	}

	return config, nil
}

// GetOpenAIConfig returns the OpenAI configuration
func (c *Config) GetOpenAIConfig() (OpenAIConfig, error) {
	if c.Embedder.Type != "openai" {
		return OpenAIConfig{}, fmt.Errorf("embedder type is not openai")
	}

	config, ok := c.Embedder.Config.(OpenAIConfig)
	if !ok {
		return OpenAIConfig{}, fmt.Errorf("invalid openai config type")
	}

	return config, nil
}

// GetQdrantConfig returns the Qdrant configuration
func (c *Config) GetQdrantConfig() (QdrantConfig, error) {
	if c.Storage.Type != "qdrant" {
		return QdrantConfig{}, fmt.Errorf("storage type is not qdrant")
	}

	config, ok := c.Storage.Config.(QdrantConfig)
	if !ok {
		return QdrantConfig{}, fmt.Errorf("invalid qdrant config type")
	}

	return config, nil
}